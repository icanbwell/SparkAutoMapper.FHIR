from __future__ import annotations
from typing import List, Optional, TYPE_CHECKING, Union

from pyspark.sql.types import StructType, DataType
from spark_auto_mapper_fhir.fhir_types.list import FhirList
from spark_auto_mapper_fhir.fhir_types.string import FhirString
from spark_auto_mapper_fhir.fhir_types.uri import FhirUri

from spark_auto_mapper_fhir.extensions.custom.nested_extension_item import (
    NestedExtensionItem,
)

from spark_auto_mapper_fhir.base_types.fhir_complex_type_base import FhirComplexTypeBase
from spark_fhir_schemas.r4.complex_types.quantity import QuantitySchema


if TYPE_CHECKING:
    pass
    # id_ (string)
    # extension (Extension)
    # value (decimal)
    from spark_auto_mapper_fhir.fhir_types.decimal import FhirDecimal

    # comparator (QuantityComparator)
    from spark_auto_mapper_fhir.value_sets.quantity_comparator import (
        QuantityComparatorCode,
    )

    # unit (string)
    # system (uri)
    # code (generic_type)
    from spark_auto_mapper_fhir.value_sets.generic_type import GenericTypeCode


# This file is auto-generated by generate_classes so do not edit manually
# noinspection PyPep8Naming
class Quantity(FhirComplexTypeBase):
    """
    Quantity
    fhir-base.xsd
        A measured amount (or an amount that can potentially be measured). Note that measured amounts include amounts that are not precisely quantified, including amounts involving arbitrary units and floating currencies.
        If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
    """

    # noinspection PyPep8Naming
    def __init__(
        self,
        *,
        use_date_for: Optional[List[str]] = None,
        id_: Optional[FhirString] = None,
        extension: Optional[FhirList[NestedExtensionItem]] = None,
        value: Optional[FhirDecimal] = None,
        comparator: Optional[QuantityComparatorCode] = None,
        unit: Optional[FhirString] = None,
        system: Optional[FhirUri] = None,
        code: Optional[GenericTypeCode] = None,
    ) -> None:
        """
            A measured amount (or an amount that can potentially be measured). Note that
        measured amounts include amounts that are not precisely quantified, including
        amounts involving arbitrary units and floating currencies.
            If the element is present, it must have a value for at least one of the
        defined elements, an @id referenced from the Narrative, or extensions

            :param id_: None
            :param extension: May be used to represent additional information that is not part of the basic
        definition of the element. To make the use of extensions safe and manageable,
        there is a strict set of governance  applied to the definition and use of
        extensions. Though any implementer can define an extension, there is a set of
        requirements that SHALL be met as part of the definition of the extension.
            :param value: The value of the measured amount. The value includes an implicit precision in
        the presentation of the value.
            :param comparator: How the value should be understood and represented - whether the actual value
        is greater or less than the stated value due to measurement issues; e.g. if
        the comparator is "<" , then the real value is < stated value.
            :param unit: A human-readable form of the unit.
            :param system: The identification of the system that provides the coded form of the unit.
            :param code: A computer processable form of the unit in some unit representation system.
        """
        super().__init__(
            id_=id_,
            extension=extension,
            value=value,
            comparator=comparator,
            unit=unit,
            system=system,
            code=code,
        )
        self.use_date_for = use_date_for

    def get_schema(
        self, include_extension: bool, extension_fields: Optional[List[str]] = None
    ) -> Optional[Union[StructType, DataType]]:
        return QuantitySchema.get_schema(
            include_extension=include_extension,
            extension_fields=extension_fields,
            use_date_for=self.use_date_for,
        )
