from __future__ import annotations
from typing import List, Optional, TYPE_CHECKING, Union

from pyspark.sql.types import StructType, DataType
from spark_auto_mapper_fhir.fhir_types.boolean import FhirBoolean
from spark_auto_mapper_fhir.fhir_types.list import FhirList
from spark_auto_mapper_fhir.fhir_types.string import FhirString
from spark_auto_mapper_fhir.fhir_types.uri import FhirUri

from spark_auto_mapper_fhir.extensions.custom.nested_extension_item import (
    NestedExtensionItem,
)

from spark_auto_mapper_fhir.base_types.fhir_complex_type_base import FhirComplexTypeBase
from spark_fhir_schemas.r4.complex_types.coding import CodingSchema


if TYPE_CHECKING:
    pass
    # id_ (string)
    # extension (Extension)
    # system (uri)
    # version (string)
    # code (generic_type)
    # display (string)
    # userSelected (boolean)


# This file is auto-generated by generate_classes so do not edit manually
# noinspection PyPep8Naming
from typing import TypeVar, Generic
from spark_auto_mapper_fhir.base_types.FhirValueSetBase import FhirValueSetBase

_T = TypeVar("_T", bound=Union[FhirValueSetBase])


class Coding(FhirComplexTypeBase, Generic[_T]):
    """
    Coding
    fhir-base.xsd
        A reference to a code defined by a terminology system.
        If the element is present, it must have a value for at least one of the defined elements, an @id referenced from the Narrative, or extensions
    """

    # noinspection PyPep8Naming
    def __init__(
        self,
        *,
        use_date_for: Optional[List[str]] = None,
        id_: Optional[FhirString] = None,
        extension: Optional[FhirList[NestedExtensionItem]] = None,
        system: Optional[FhirUri] = None,
        version: Optional[FhirString] = None,
        code: Optional[_T] = None,
        display: Optional[FhirString] = None,
        userSelected: Optional[FhirBoolean] = None,
    ) -> None:
        """
            A reference to a code defined by a terminology system.
            If the element is present, it must have a value for at least one of the
        defined elements, an @id referenced from the Narrative, or extensions

            :param id_: None
            :param extension: May be used to represent additional information that is not part of the basic
        definition of the element. To make the use of extensions safe and manageable,
        there is a strict set of governance  applied to the definition and use of
        extensions. Though any implementer can define an extension, there is a set of
        requirements that SHALL be met as part of the definition of the extension.
            :param system: The identification of the code system that defines the meaning of the symbol
        in the code.
            :param version: The version of the code system which was used when choosing this code. Note
        that a well-maintained code system does not need the version reported, because
        the meaning of codes is consistent across versions. However this cannot
        consistently be assured, and when the meaning is not guaranteed to be
        consistent, the version SHOULD be exchanged.
            :param code: A symbol in syntax defined by the system. The symbol may be a predefined code
        or an expression in a syntax defined by the coding system (e.g. post-
        coordination).
            :param display: A representation of the meaning of the code in the system, following the rules
        of the system.
            :param userSelected: Indicates that this coding was chosen by a user directly - e.g. off a pick
        list of available items (codes or displays).
        """
        super().__init__(
            id_=id_,
            extension=extension,
            system=system,
            version=version,
            code=code,
            display=display,
            userSelected=userSelected,
        )
        self.use_date_for = use_date_for

    def get_schema(
        self, include_extension: bool, extension_fields: Optional[List[str]] = None
    ) -> Optional[Union[StructType, DataType]]:
        return CodingSchema.get_schema(
            include_extension=include_extension,
            extension_fields=extension_fields,
            use_date_for=self.use_date_for,
        )
