from __future__ import annotations
from typing import Optional, TYPE_CHECKING, Union

# noinspection PyPackageRequirements
from pyspark.sql.types import StructType, DataType
from spark_auto_mapper_fhir.fhir_types.list import FhirList
from spark_auto_mapper_fhir.complex_types.meta import Meta
from spark_auto_mapper_fhir.extensions.extension_base import ExtensionBase
from spark_auto_mapper_fhir.fhir_types.id import FhirId

from spark_auto_mapper_fhir.base_types.fhir_resource_base import FhirResourceBase
from spark_fhir_schemas.r4.resources.binary import BinarySchema

if TYPE_CHECKING:
    pass
    # contentType (Mime Types)
    from spark_auto_mapper_fhir.value_sets.mime_types import MimeTypesCode

    # securityContext (Reference)
    from spark_auto_mapper_fhir.complex_types.reference import Reference

    # Imports for References for securityContext
    from spark_auto_mapper_fhir.resources.resource import Resource

    # data (base64Binary)
    from spark_auto_mapper_fhir.complex_types.base64_binary import base64Binary


# This file is auto-generated by generate_classes so do not edit manually
# noinspection PyPep8Naming
class Binary(FhirResourceBase):
    """
    Binary
    """

    # noinspection PyPep8Naming
    def __init__(
        self,
        *,
        id_: FhirId,
        meta: Optional[Meta] = None,
        extension: Optional[FhirList[ExtensionBase]] = None,
        contentType: MimeTypesCode,
        securityContext: Optional[Reference[Union[Resource]]] = None,
        data: Optional[base64Binary] = None,
    ) -> None:
        """

            :param id_: id of resource
            :param meta: Meta
            :param extension: extensions
            :param contentType: MimeType of the binary content represented as a standard MimeType (BCP 13).
            :param securityContext: This element identifies another resource that can be used as a proxy of the
        security sensitivity to use when deciding and enforcing access control rules
        for the Binary resource. Given that the Binary resource contains very few
        elements that can be used to determine the sensitivity of the data and
        relationships to individuals, the referenced resource stands in as a proxy
        equivalent for this purpose. This referenced resource may be related to the
        Binary (e.g. Media, DocumentReference), or may be some non-related Resource
        purely as a security proxy. E.g. to identify that the binary resource relates
        to a patient, and access should only be granted to applications that have
        access to the patient.
            :param data: The actual content, base64 encoded.
        """
        super().__init__(
            resourceType="Binary",
            id_=id_,
            meta=meta,
            extension=extension,
            contentType=contentType,
            securityContext=securityContext,
            data=data,
        )

    def get_schema(
        self, include_extension: bool
    ) -> Optional[Union[StructType, DataType]]:
        return BinarySchema.get_schema(include_extension=include_extension)
